# 📋 Детальный план улучшения Dream Analyzer

## 🎯 Общая стратегия разбивки

Каждая задача спроектирована как **независимый сеанс работы** с четким входом и выходом. План учитывает зависимости и позволяет параллельное выполнение.

---

## 🔒 БЛОК 1: БЕЗОПАСНОСТЬ И ИНФРАСТРУКТУРА

### Задача 1.1: Создание общей библиотеки авторизации
**Приоритет:** 🔴 Критический  
**Время:** 45-60 минут  
**Зависимости:** Нет  

#### Контекст для ИИ:
```
Проект Dream Analyzer - Telegram Mini App с анализом снов. 
Проблема: функция validateTelegramData дублируется в 4 файлах.
Цель: создать переиспользуемую библиотеку авторизации.

Файлы для изучения:
- bot/functions/deep-analysis.js (строки 33-81)
- bot/functions/create-invoice.js (строки 10-40) 
- bot/functions/web-login.js (строки 1-105)
- bot/functions/user-profile.js (если есть)
```

#### Задачи:
1. Создать `bot/functions/shared/auth/telegram-validator.js`
2. Вынести функцию `validateTelegramData` в отдельный модуль
3. Добавить JSDoc документацию
4. Создать типы для TypeScript
5. Обновить все 4 функции для использования общей библиотеки
6. Добавить unit тесты для валидатора

#### Критерии готовности:
- [ ] Создан переиспользуемый модуль
- [ ] Все функции используют общую библиотеку
- [ ] Добавлена документация
- [ ] Тесты покрывают основные сценарии

---

### Задача 1.2: Централизация CORS и обработки ошибок
**Приоритет:** 🟡 Высокий  
**Время:** 30-45 минут  
**Зависимости:** Задача 1.1  

#### Контекст для ИИ:
```
После выполнения задачи 1.1 нужно централизовать CORS настройки и обработку ошибок.
Каждая Netlify Function дублирует логику CORS и error handling.

Изучить файлы:
- bot/functions/deep-analysis.js (строки 86-94, 128-270)
- bot/functions/create-invoice.js (строки 42-51, 53-156)
- bot/functions/analyze-dream.js (строки 39-141)
```

#### Задачи:
1. Создать `bot/functions/shared/middleware/cors.js`
2. Создать `bot/functions/shared/middleware/error-handler.js`
3. Создать wrapper функцию для API handlers
4. Обновить все функции для использования middleware
5. Стандартизировать формат ошибок

#### Критерии готовности:
- [ ] Единообразные CORS заголовки
- [ ] Стандартизированная обработка ошибок
- [ ] Уменьшение дублирования кода на 60%+

---

### Задача 1.3: Безопасное хранение токенов в веб-приложении
**Приоритет:** 🟡 Высокий  
**Время:** 60-90 минут  
**Зависимости:** Нет  

#### Контекст для ИИ:
```
Веб-приложение хранит JWT токены в localStorage, что небезопасно.
Нужно реализовать httpOnly cookies + refresh token pattern.

Файлы для изучения:
- web/src/App.vue (строки 98-104, 200-207)
- web/src/components/Login.vue (строки 69-71)
- bot/functions/web-login.js (строки 86-94)
```

#### Задачи:
1. Модифицировать `web-login.js` для возврата httpOnly cookie
2. Создать refresh token mechanism
3. Обновить Frontend для работы с cookies
4. Добавить автоматическое обновление токенов
5. Реализовать secure logout

#### Критерии готовности:
- [ ] JWT в httpOnly cookies
- [ ] Refresh token реализован
- [ ] Автоматическое обновление токенов
- [ ] Защита от XSS атак

---

## 🏗️ БЛОК 2: РЕФАКТОРИНГ И АРХИТЕКТУРА

### Задача 2.1: Создание Gemini API сервиса
**Приоритет:** 🟡 Высокий  
**Время:** 45-60 минут  
**Зависимости:** Нет  

#### Контекст для ИИ:
```
Логика работы с Gemini API дублируется в bot.js и analyze-dream.js.
Модель переинициализируется в каждом запросе.

Файлы для анализа:
- bot/functions/bot.js (строки 322-370, 12-35)
- bot/functions/analyze-dream.js (строки 13-37)
- bot/functions/deep-analysis.js (строки 96-125)
```

#### Задачи:
1. Создать `bot/functions/shared/services/gemini-service.js`
2. Реализовать Singleton pattern для Gemini client
3. Вынести все AI промпты в отдельный файл
4. Добавить retry mechanism и error handling
5. Реализовать кеширование результатов (memory cache)
6. Обновить все функции для использования сервиса

#### Критерии готовности:
- [ ] Единый Gemini сервис
- [ ] Промпты в отдельном файле
- [ ] Retry и error handling
- [ ] Memory caching реализован

---

### Задача 2.2: Рефакторинг bot.js - разделение на модули
**Приоритет:** 🟡 Высокий  
**Время:** 90-120 минут  
**Зависимости:** Задачи 1.1, 2.1  

#### Контекст для ИИ:
```
Файл bot.js содержит 436 строк с множественной ответственностью.
Нужно разбить на отдельные модули по принципу Single Responsibility.

Изучить:
- bot/functions/bot.js (весь файл)

Проблемы:
- Смешана инициализация, обработка команд, бизнес-логика
- Функции >50 строк
- Нет разделения concerns
```

#### Задачи:
1. Создать структуру:
   ```
   bot/functions/bot/
   ├── handlers/
   │   ├── start-command.js
   │   ├── setpassword-command.js  
   │   ├── text-message.js
   │   └── payment-handlers.js
   ├── services/
   │   ├── user-service.js
   │   └── message-service.js
   └── bot.js (основной файл)
   ```
2. Вынести каждый handler в отдельный файл
3. Создать UserService для работы с пользователями
4. Создать MessageService для отправки сообщений
5. Реорганизовать основной bot.js как композицию

#### Критерии готовности:
- [ ] Каждый handler в отдельном файле (<100 строк)
- [ ] Сервисы выделены
- [ ] Основной файл <100 строк
- [ ] Четкое разделение ответственности

---

### Задача 2.3: Оптимизация работы с базой данных
**Приоритет:** 🟠 Средний  
**Время:** 60-75 минут  
**Зависимости:** Нет  

#### Контекст для ИИ:
```
Множественные SELECT запросы вместо JOIN операций.
Отсутствие connection pooling и batch операций.

Файлы для анализа:
- bot/functions/deep-analysis.js (строки 169-241)
- bot/functions/bot.js (строки 280-318, 373-414)
- tma/src/stores/user.js (строки 75-101)
```

#### Задачи:
1. Создать `bot/functions/shared/database/queries.js`
2. Заменить множественные SELECT на JOIN запросы
3. Добавить prepared statements
4. Реализовать batch операции где возможно
5. Добавить connection pooling configuration
6. Создать database health check

#### Критерии готовности:
- [ ] JOIN запросы вместо множественных SELECT
- [ ] Prepared statements
- [ ] Batch операции
- [ ] Health check endpoint

---

## 🎨 БЛОК 3: UX/UI УЛУЧШЕНИЯ

### Задача 3.1: Система уведомлений для TMA
**Приоритет:** 🟠 Средний  
**Время:** 60-90 минут  
**Зависимости:** Нет  

#### Контекст для ИИ:
```
TMA приложение использует примитивные alert() для уведомлений.
Нужна красивая система toast/notification.

Файлы для изучения:
- tma/src/stores/user.js (строки 141, 149, 284-292)
- tma/src/views/PersonalAccount.vue
- tma/src/App.vue
```

#### Задачи:
1. Создать `tma/src/components/NotificationSystem.vue`
2. Создать `tma/src/stores/notifications.js` store
3. Добавить разные типы уведомлений (success, error, warning, info)
4. Реализовать auto-dismiss и manual dismiss
5. Заменить все alert() на новую систему
6. Добавить анимации и красивый дизайн

#### Критерии готовности:
- [ ] Компонент NotificationSystem создан
- [ ] Store для уведомлений
- [ ] 4 типа уведомлений
- [ ] Все alert() заменены

---

### Задача 3.2: Улучшение состояний загрузки
**Приоритет:** 🟠 Средний  
**Время:** 45-60 минут  
**Зависимости:** Нет  

#### Контекст для ИИ:
```
Неконсистентные loading states и отсутствие skeleton screens.
Плохой UX при долгих операциях.

Файлы для изучения:
- tma/src/stores/user.js (все loading флаги)
- tma/src/components/UserInfoCard.vue
- web/src/App.vue (строки 14-29, 45-65)
```

#### Задачи:
1. Создать `tma/src/components/LoadingSpinner.vue`
2. Создать `tma/src/components/SkeletonLoader.vue`
3. Добавить прогресс-бар для анализа снов
4. Стандартизировать все loading states
5. Добавить timeout handling для long operations
6. Улучшить UX для медленного интернета

#### Критерии готовности:
- [ ] Единообразные loading компоненты
- [ ] Skeleton screens
- [ ] Прогресс-бар для анализа
- [ ] Timeout handling

---

### Задача 3.3: Улучшение обработки ошибок в UI
**Приоритет:** 🟠 Средний  
**Время:** 45-60 минут  
**Зависимости:** Задача 3.1  

#### Контекст для ИИ:
```
Примитивная обработка ошибок в UI. Нужны retry механизмы и
user-friendly сообщения.

Файлы для изучения:
- tma/src/stores/user.js (error handling)
- web/src/App.vue (error states)
- web/src/components/Login.vue (строки 76-82)
```

#### Задачи:
1. Создать `ErrorBoundary` компонент
2. Добавить retry кнопки для failed операций
3. Создать user-friendly error messages
4. Добавить offline detection и handling
5. Реализовать fallback UI для критических ошибок
6. Добавить error reporting (опционально)

#### Критерии готовности:
- [ ] ErrorBoundary компонент
- [ ] Retry механизмы
- [ ] User-friendly сообщения
- [ ] Offline handling

---

## 🧪 БЛОК 4: ТЕСТИРОВАНИЕ

### Задача 4.1: Unit тесты для утилит и сервисов
**Приоритет:** 🟠 Средний  
**Время:** 90-120 минут  
**Зависимости:** Задачи 1.1, 2.1  

#### Контекст для ИИ:
```
Проект полностью без тестов. Нужно начать с unit тестов для
core утилит и сервисов.

Созданные модули из предыдущих задач:
- shared/auth/telegram-validator.js
- shared/services/gemini-service.js
- shared/middleware/cors.js
```

#### Задачи:
1. Настроить Jest для Node.js тестирования
2. Создать тесты для telegram-validator
3. Создать тесты для gemini-service (с mocking)
4. Создать тесты для CORS middleware
5. Настроить GitHub Actions для запуска тестов
6. Добавить coverage reporting

#### Критерии готовности:
- [ ] Jest настроен
- [ ] 80%+ coverage для utils
- [ ] CI/CD pipeline с тестами
- [ ] Coverage reports

---

### Задача 4.2: Интеграционные тесты для API
**Приоритет:** 🟢 Низкий  
**Время:** 120-150 минут  
**Зависимости:** Задача 4.1  

#### Контекст для ИИ:
```
Нужны интеграционные тесты для Netlify Functions.
Тестирование полного flow от HTTP запроса до ответа.

API endpoints для тестирования:
- /analyze-dream
- /deep-analysis  
- /user-profile
- /web-login
```

#### Задачи:
1. Настроить test environment для Netlify Functions
2. Создать test database setup/teardown
3. Написать тесты для каждого API endpoint
4. Добавить тесты для error scenarios
5. Тестировать authentication flow
6. Добавить performance тесты

#### Критерии готовности:
- [ ] Тесты для всех endpoints
- [ ] Error scenarios покрыты
- [ ] Test DB setup
- [ ] Performance benchmarks

---

## ⚡ БЛОК 5: ПРОИЗВОДИТЕЛЬНОСТЬ

### Задача 5.1: Реализация кеширования
**Приоритет:** 🟢 Низкий  
**Время:** 75-90 минут  
**Зависимости:** Задача 2.1  

#### Контекст для ИИ:
```
Отсутствует кеширование для повторяющихся операций.
Gemini API дорогой, результаты можно кешировать.

Файлы для изучения:
- shared/services/gemini-service.js (из задачи 2.1)
- bot/functions/user-profile.js
```

#### Задачи:
1. Реализовать Redis-совместимый memory cache
2. Добавить кеширование для Gemini responses
3. Кешировать user profiles
4. Добавить cache invalidation strategies
5. Реализовать cache warming для популярных запросов
6. Добавить cache monitoring

#### Критерии готовности:
- [ ] Memory cache реализован
- [ ] Gemini responses кешируются
- [ ] Cache invalidation
- [ ] Monitoring metrics

---

### Задача 5.2: Оптимизация bundle size
**Приоритет:** 🟢 Низкий  
**Время:** 60-75 минут  
**Зависимости:** Нет  

#### Контекст для ИИ:
```
Нужна оптимизация размера bundle для TMA и Web приложений.
Уменьшение времени загрузки.

Файлы для анализа:
- tma/package.json
- web/package.json
- tma/vite.config.js
- web/vite.config.js
```

#### Задачи:
1. Анализировать текущий bundle size
2. Реализовать code splitting
3. Добавить tree shaking оптимизации
4. Оптимизировать imports (lazy loading)
5. Compress assets и добавить gzip
6. Настроить chunk splitting strategies

#### Критерии готовности:
- [ ] Bundle size анализ
- [ ] Code splitting реализован
- [ ] 30%+ уменьшение размера
- [ ] Lazy loading ключевых компонентов

---

## 📊 БЛОК 6: МОНИТОРИНГ И ЛОГИРОВАНИЕ

### Задача 6.1: Структурированное логирование
**Приоритет:** 🟢 Низкий  
**Время:** 60-75 минут  
**Зависимости:** Задача 1.2  

#### Контекст для ИИ:
```
Все логирование через console.log/error без структуры.
Нужна централизованная система логирования.

Текущее логирование в:
- bot/functions/bot.js (множественные console.log)
- bot/functions/deep-analysis.js
- shared/middleware/ (из задачи 1.2)
```

#### Задачи:
1. Создать `shared/utils/logger.js` с Winston
2. Добавить structured logging (JSON format)
3. Настроить log levels (error, warn, info, debug)
4. Добавить correlation IDs для трассировки
5. Интегрировать с external logging service
6. Заменить все console.* на structured logger

#### Критерии готовности:
- [ ] Winston logger настроен
- [ ] JSON structured logs
- [ ] Correlation IDs
- [ ] External service интеграция

---

### Задача 6.2: Monitoring и алерты
**Приоритет:** 🟢 Низкий  
**Время:** 90-120 минут  
**Зависимости:** Задача 6.1  

#### Контекст для ИИ:
```
Отсутствует мониторинг производительности и здоровья приложения.
Нужны метрики и алерты.
```

#### Задачи:
1. Настроить health check endpoints
2. Добавить performance метрики
3. Реализовать error rate monitoring
4. Настроить Telegram alerting
5. Добавить business метрики (анализы/день)
6. Создать simple dashboard

#### Критерии готовности:
- [ ] Health checks работают
- [ ] Performance метрики
- [ ] Error rate tracking
- [ ] Telegram алерты

---

## 🎯 РЕКОМЕНДУЕМЫЙ ПОРЯДОК ВЫПОЛНЕНИЯ

### Фаза 1 (Критическая) - 2-3 дня:
1. **Задача 1.1** - Общая библиотека авторизации
2. **Задача 1.2** - CORS и error handling  
3. **Задача 2.1** - Gemini API сервис

### Фаза 2 (Высокий приоритет) - 3-4 дня:
4. **Задача 1.3** - Безопасное хранение токенов
5. **Задача 2.2** - Рефакторинг bot.js
6. **Задача 3.1** - Система уведомлений

### Фаза 3 (Средний приоритет) - 2-3 дня:
7. **Задача 2.3** - Оптимизация БД
8. **Задача 3.2** - Loading states
9. **Задача 3.3** - Error handling UI

### Фаза 4 (Стабилизация) - 3-4 дня:
10. **Задача 4.1** - Unit тесты
11. **Задача 6.1** - Логирование
12. **Задача 5.1** - Кеширование

### Фаза 5 (Полировка) - 2-3 дня:
13. **Задача 4.2** - Интеграционные тесты
14. **Задача 5.2** - Bundle оптимизация
15. **Задача 6.2** - Мониторинг

---

## 📝 Шаблон для каждого чата

При начале новой задачи, используйте этот шаблон:

```
ЗАДАЧА: [Номер и название задачи]

КОНТЕКСТ ПРОЕКТА:
Dream Analyzer - Telegram Mini App для анализа снов с:
- Telegram Bot на Grammy
- TMA на Vue 3 + Pinia
- Web версия на Vue 3  
- Backend на Netlify Functions
- БД Supabase
- AI через Gemini API

ПРЕДЫДУЩИЕ ВЫПОЛНЕННЫЕ ЗАДАЧИ:
[Список завершенных задач с ссылками на их результаты]

ФАЙЛЫ ДЛЯ ИЗУЧЕНИЯ:
[Конкретные файлы и строки из задачи]

ЦЕЛЬ:
[Конкретная цель из описания задачи]

КРИТЕРИИ ГОТОВНОСТИ:
[Чекпоинты из задачи]
```

Этот план позволяет работать параллельно над независимыми частями и поддерживать фокус в каждом отдельном чате.